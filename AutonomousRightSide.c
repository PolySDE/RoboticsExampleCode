#pragma config(Hubs,  S1, HTMotor,  none,     none,     none)
#pragma config(Sensor, S3,     US1,            sensorI2CCustom9V)
#pragma config(Sensor, S4,     US2,            sensorI2CCustom9V)
#pragma config(Motor,  motorB,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorC,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  mtr_S1_C1_1,     motorLeft,     tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     motorRight,    tmotorTetrix, openLoop, reversed, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "drivers/lego-ultrasound.h";
#include "JoystickDriver.c"
void initializeRobot(){
  return;
}
int dist[2] = {
	-1,-1
};
int dir = 0;
float arcLength(float turnRadius, float degToTurn){
	float length = 2*PI*(((float) degToTurn)/360);
	return length;
}
float degToTurn(float distance, float radiusOfTire){
	float degrees = (180*distance)/(2*PI*radiusOfTire);
	return degrees;
}
int getDistanceSingleShot(tSensors link){//measure distance from an ultrasonic sensor
		USsetSingleMode(link);                 //use single shot mode
		wait1Msec(50);                        //wait for 50ms
		int thisDist = USreadDist(link);              //read the distance
		USsetOff(link);                        //turn off motor to prevent interference.
		return thisDist; //return distance
}
int findDirection(){ //find direction robot is facing using ultrasonic sensors
	int left = getDistanceSingleShot(US1);
	int right = getDistanceSingleShot(US2);
	if(abs(left-right)<=2){
		return 0;	//is straight
	} else if(left>right){
		return 1; //is going to the left of the wall, left is farther
	} else if(right>left){
		return 2; //is going to the right of the wall, right is farther
	}
	return -1;
}
void rotationChecker(){
	int dir = findDirection();
	nxtDisplayClearTextLine(5);
	nxtDisplayTextLine(5, "%d", dir);
}
void turnInPlace(float degreesToTurn){
	float degs = degToTurn(arcLength(7.5, abs(degreesToTurn)), 1.5);
	float encoderTicks = (degs/((float)360));
	if(degreesToTurn>0){
		nMotorEncoder[motorLeft] = 0;
		nMotorEncoder[motorRight] = 0;
		while(abs(nMotorEncoder[motorLeft])<encoderTicks && abs(nMotorEncoder[motorRight])<encoderTicks){
			if(abs(nMotorEncoder[motorLeft])<encoderTicks){
				motor[motorLeft] = 40;
			} else {
				motor[motorLeft] = 0;
			}
			if(abs(nMotorEncoder[motorRight])<encoderTicks){
				motor[motorRight] = -40;
			} else {
				motor[motorRight] = 0;
			}
		}
	}

}
void wait(int time){
	wait1Msec(time);
}
void stopAllMotors(){
	motor[motorLeft] = 0;
	motor[motorRight] = 0;
}
void drive(int power, float steer){//function to drive with a certain speed while vering.
	float steerF = steer/100;
	int left = power;
	int right = power;
	if(steer==0){
		//do nothing
	} else if(steer>0 && power>0){
		//subtract from right
		right -= (int)(power*steerF);
	} else if(steer<0 && power>0){
		//subtract from left
		left -= (int)(power*abs(steerF));
	} else if(steer>0 && power<0){
		//subtract from right
		right += (int)(power*steerF);
	} else if(steer<0 && power<0){
		//subtract from left
		left += (int)(power*abs(steerF));
	}
	motor[motorLeft] = left;
	motor[motorRight] = right;
}
void turnInPlace2(int direction, int degrees){
	int time=0;
	if(degrees==22){
		time = 250;
	}
	if(degrees==45){
		time = 500;
	}
	if(degrees==90){
		time = 1000;
	}
	if(direction==0){
		drive(20, -200);
		wait(time);
		stopAllMotors();
	}
	if(direction==1){
		drive(20, 200);
		wait(time);
		stopAllMotors();
	}
}

task getUS(){//task to continually capture distances from US sensors
	while(true){
		int left = getDistanceSingleShot(US1);
		int right = getDistanceSingleShot(US2);
		dist[0] = left;
		dist[1] = right;
		//writeDebugStreamLine("[%d]Left Distance: %d", (nPgmTime/10),left);
		//writeDebugStreamLine("[%d]Right Distance: %d", (nPgmTime/10),right);
		if(abs(left-right)<=2){
			dir = 0;	//is straight
		} else if(left>right){
			dir = 1; //is going to the left of the wall, left is farther
		} else if(right>left){
			dir = 2; //is going to the right of the wall, right is farther
		}
		//writeDebugStreamLine("[%d]Direction: %d", nPgmTime,dir);
	}
}
task main()
{
	initializeRobot();
  waitForStart();
	while(true){
		int power = 20;
		turnInPlace2(0, 45);
		drive(20, 0);
		wait(1000);
		turnInPlace2(1, 45);
		turnInPlace2(1, 22);
		drive(20, 0);
		wait(300);
		drive(-20, 0);
		wait(1000);
		turnInPlace2(1, 45);
		drive(20,0);
		wait(1000);
		turnInPlace2(0, 45);
		drive(20,0);
		wait(500);
	//	turnInPlace2(0,45);
	//	turnInPlace2(0,22);
	//	drive(40,0);
		wait(1500);
		StopAllTasks();
	}
}
